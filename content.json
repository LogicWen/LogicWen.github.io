{"meta":{"title":"Whyme的博客","subtitle":"克己 慎独","description":"尘世中一个沉浮的小码农","author":"Whyme","url":"http://yoursite.com"},"pages":[{"title":"my-second-blog","date":"2018-09-06T08:58:18.000Z","updated":"2018-09-06T08:58:18.776Z","comments":true,"path":"my-second-blog/index.html","permalink":"http://yoursite.com/my-second-blog/index.html","excerpt":"","text":""}],"posts":[{"title":"test_from_maxiang","slug":"test-from-maxiang","date":"2018-09-06T09:22:32.000Z","updated":"2018-09-07T06:52:27.625Z","comments":true,"path":"2018/09/06/test-from-maxiang/","link":"","permalink":"http://yoursite.com/2018/09/06/test-from-maxiang/","excerpt":"Java垃圾回收[TOC] Java对象的内存布局mark word（对象头） –&gt; class point（类指针，指向类的数据） –&gt; instance data（对象的数据） –&gt;padding（对齐填充，8个字节对齐的）32位系统中refrence是四个字节，64位中的是八个字节 Java是通引用来访问对象的。 某个方法，先找到这个对象，再找这个对象的类，再找父类。","text":"Java垃圾回收[TOC] Java对象的内存布局mark word（对象头） –&gt; class point（类指针，指向类的数据） –&gt; instance data（对象的数据） –&gt;padding（对齐填充，8个字节对齐的）32位系统中refrence是四个字节，64位中的是八个字节 Java是通引用来访问对象的。 某个方法，先找到这个对象，再找这个对象的类，再找父类。 Java早期的GC方法引用计数法缺点：相互引用 循环引用不行 Java根节点可达性分析一开始是这个方法从GC Roots找。 那些对象可以作为根节点？ 虚拟机栈中引用对象（局部变量表） 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 如何进行垃圾回收标记-清除 算法（Mark-Sweep）第一阶段进行标记，第二阶段进行清除，产生了内存碎片 复制算法（Copying）[新生代的方法]按照容量分成两块，把能够活下来的copy，把之前的清零。这个和存活的多少有关。（前提是活的对象少，死的对象多） 标记-整理算法（Mark-Compact）[老年代的方法]移动对象到一端，然后清理掉端边界以外的对象 分代算法（因为每次浪费一半的内存，改进了）Eden和Survivor1 Survivor2（8:1:1）新生代是minorGC当Survivor2空间不够，则以来其他内存（放入老年代） 当Eden满了之后，清算eden和survivor两个区域里面的对象 当年老代满了，将会进行一次full GC。 存入年老代的对象：1.放不下了 2.经过了很多次minor GC 永久代：方法区。（permnate generate） 永久代的回收： 废弃无用的常量（常量池中的“abc”已经没有被任何字符串引用）无用的类（所有实例都被回收 or 加载该类的classloader被回收 or Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法 ）垃圾回收的性价比比较低 对象分配和垃圾回收对象优先在新生代Eden分配，新生代minorGC的速度快，而且频繁，性价比高大对象直接进入老年代：通过-XX:PretenureSizeThreshold控制长期存活对象进入老年代：age &gt; MaxTenuringThreshold（minorGC一次，年龄加1，默认是15）动态年龄判断： 当某个年龄的对象个数大于该survivor空间的一半，大于等于该年龄对象直接进入老年代 GC的时候会Stop the world! HandlerPromotionFailure对象分配担保。 垃圾回收的实现 Serial/Serial Old（串行） stop the world GC线程是单线程的Parnew（并行）也需要暂停用户线程，只是多个线程进行垃圾回收， 添加了一个safepointParallel Scavenge/Parallel Old（吞吐量优先的）CMS（最短回收）[初始标记 并发标记 重新标记 并发清理 重置线程]G1（面向服务端应用的来讲收集器，采用标记-整理算法）[G1收集器可以独立管理两个代的GC] JVM的两种运行模式：client 和 server 模式","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-09-06T08:35:05.682Z","updated":"2018-09-06T09:06:19.182Z","comments":true,"path":"2018/09/06/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第一个测试日志","slug":"测试blog","date":"2013-12-02T07:30:16.000Z","updated":"2018-09-11T05:41:18.927Z","comments":true,"path":"2013/12/02/测试blog/","link":"","permalink":"http://yoursite.com/2013/12/02/测试blog/","excerpt":"","text":"以下是正文","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/默认分类/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://yoursite.com/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://yoursite.com/tags/tag2/"},{"name":"tag3","slug":"tag3","permalink":"http://yoursite.com/tags/tag3/"}]}]}